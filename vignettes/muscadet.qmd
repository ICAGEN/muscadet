---
title: "Introduction to muscadet"
vignette: >
  %\VignetteIndexEntry{Introduction to muscadet}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
format:
  html:
    toc: true
    toc-location: right
    code-tools: true
    number-sections: true
    link-external-icon: true
    link-external-newwindow: true
    embed-resources: true
depends:
  - clustree
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
---

```{r}
#| label: setup
#| include: false
if (!dir.exists("figures")) dir.create("figures")
library(SeuratObject)
library(knitr)
library(dplyr)
library(ggplot2)
if (requireNamespace("clustree", quietly = TRUE)) {
  library(clustree)
}
has_clustree <- requireNamespace("clustree", quietly = TRUE)
```


`muscadet` (**mu**ltiomics **s**ingle-cell **c**opy number **a**lterations **det**ection) is an R package designed to identify somatic copy number alterations (CNAs) in cancer cells using single-cell multiomics data. 
The package supports analyses ranging from a single omics layer to multiple omics measured on the same cells, and is designed to accommodate partially missing-modality scenarios. `muscadet` enables the identification of tumor subclones through multi-omic cell clustering and provides downstream tools for CNA inference within a unified and reproducible workflow.


# Installation

The latest version of muscadet can be installed directly from GitHub:

```{r}
#| label: installation
#| eval: false
library(devtools)
devtools::install_github("ICAGEN/muscadet")
```


# Inputs and objects creation

::: {.callout-important}
## Important note on example data
The example dataset included in `muscadet` is a toy dataset designed for demonstration purposes only. It is deliberately minimal and contains a reduced genomic representation (three chromosomes). Its sole purpose is to illustrate how to run the main functions and explore the package features. Because of this strong simplification, the results obtained from this dataset should not be interpreted as biologically meaningful or methodologically representative.
:::

## muscomic

The `muscomic` objects (see `?muscomic`) are the primary objects used throughout the muscadet workflow. Each `muscomic` object represents a single omics layer and serves as the basic building block for downstream multi-omic integration, clustering, and copy-number analysis in muscadet. They are created using the `CreateMuscomicObject()` function and encapsulate all information related to a single omics modality. The function requires the following inputs:

* `type`: the type of omic modality, currently `"RNA"` and `"ATAC"` are supported. Other DNA-based modalities can be provided using the `"ATAC"` type.
* `mat_counts`: a raw count matrix with cells as rows and features as columns (see `?exdata_mat_counts`).
* `allele_counts`: a data frame of raw allele-specific counts (see `?exdata_allele_counts`) *(optional, can be added later in the analysis workflow)*.
* `features`: a data frame containing genomic coordinates of features (see `?exdata_features`).

```{r}
#| label: muscomic objs tumor
library(muscadet)

# Load example dataset inputs:
# Matrices of raw counts per features
data("exdata_mat_counts_atac_tumor", "exdata_mat_counts_rna_tumor")
# Table of raw counts per allele
data("exdata_allele_counts_atac_tumor", "exdata_allele_counts_rna_tumor")
# Table of feature coordinates
data("exdata_peaks", "exdata_genes")

# Create individual omic objects
atac <- CreateMuscomicObject(
    type = "ATAC",
    mat_counts = exdata_mat_counts_atac_tumor, 
    allele_counts = exdata_allele_counts_atac_tumor, 
    features = exdata_peaks)
rna <- CreateMuscomicObject(
    type = "RNA",
    mat_counts = exdata_mat_counts_rna_tumor,
    allele_counts = exdata_allele_counts_rna_tumor,
    features = exdata_genes)

atac

rna
```

## muscadet

The `muscadet` objects (see `?muscadet`) are higher-level containers that group one or more `muscomic` objects together with additional metadata and analysis results. They are used to store and manage the outputs of downstream steps, including clustering, and CNA calling.

A `muscadet` object is created using the `CreateMuscadetObject()` function, which takes as input a list of `muscomic` objects, optional bulk coverage information (see `?exdata_bulk_lrr`), and the genome assembly to be used for the analysis.


```{r}
#| label: muscadet obj tumor
# Table of coverage information (log ratio) from bulk data (i.e. WGS)
data("exdata_bulk_lrr")

# Create multiomic muscadet object
muscadet <- CreateMuscadetObject(
    omics = list(ATAC = atac, RNA = rna),
    bulk.lrr = exdata_bulk_lrr,
    bulk.label = "WGS",
    genome = "hg38")
muscadet
```

The reference cells data must be stored in its own `muscadet` object
```{r}
#| label: muscomic objs ref

data("exdata_mat_counts_atac_ref", "exdata_mat_counts_rna_ref")
data("exdata_allele_counts_atac_ref", "exdata_allele_counts_rna_ref")

atac_ref <- CreateMuscomicObject(
    type = "ATAC",
    mat_counts = exdata_mat_counts_atac_ref,
    allele_counts = exdata_allele_counts_atac_ref,
    features = exdata_peaks)
rna_ref <- CreateMuscomicObject(
    type = "RNA",
    mat_counts = exdata_mat_counts_rna_ref,
    allele_counts = exdata_allele_counts_rna_ref,
    features = exdata_genes)
muscadet_ref <- CreateMuscadetObject(
    omics = list(ATAC = atac_ref, RNA = rna_ref),
    genome = "hg38")
muscadet_ref
```

Examples of complete `muscadet` objects are included in the example dataset of the package.
```{r}
#| label: muscadet object
# Example of muscadet object
data("exdata_muscadet", "exdata_muscadet_ref")
exdata_muscadet
exdata_muscadet_ref
```

## Methods

Several method functions are available to access data within `muscadet`/`muscomic` objects.
```{r}
#| label: methods
#| eval: false
library(SeuratObject) # Cells() and Features() methods imported from SeuratObject

# Cell names
Cells(exdata_muscadet) # list of cells, one element per omic
Cells(exdata_muscadet)$ATAC # element of the list
Cells(exdata_muscadet$ATAC) # cells for muscomic object
Reduce(union, Cells(exdata_muscadet)) # all cells
Reduce(intersect, Cells(exdata_muscadet)) # common cells

# Feature names
Features(exdata_muscadet) # list, one element per omic
Features(exdata_muscadet)$ATAC

# Matrix of raw counts
matCounts(exdata_muscadet) # list, one element per omic
matCounts(exdata_muscadet$ATAC)

# Matrix of log ratios
matLogRatio(exdata_muscadet) # list, one element per omic
matLogRatio(exdata_muscadet)$ATAC

# Table of feature coordinates
coordFeatures(exdata_muscadet) # list, one element per omic
coordFeatures(exdata_muscadet)$RNA
```


```{r}
#| label: methods 2
library(SeuratObject) # Cells() and Features() methods imported from SeuratObject

# number of cells in total
length(Reduce(union, Cells(exdata_muscadet)))
# number of common cells
length(Reduce(intersect, Cells(exdata_muscadet)))
# number of cells per omic
lapply(Cells(exdata_muscadet), length)
# number of features per omic
lapply(Features(exdata_muscadet), length)
```


# Compute log ratios

Genome-wide coverage profiles are computed as log R ratio (LRR) matrices using the `computeLogRatio()` function for each omics modality contained in the muscadet object. This step transforms raw count data into normalized coverage profiles along the genome, which are used for downstream clustering analysis.

```{r}
#| label: compute LRR
#| eval: false

# Compute log R ratios from scATAC-seq read counts
exdata_muscadet <- computeLogRatio(
    x = exdata_muscadet,
    reference = exdata_muscadet_ref,
    omic = "ATAC",
    method = "ATAC",
    minReads = 0.5, # low value for small example dataset
    minPeaks = 1) # low value for small example dataset

# Compute log R ratios from scRNA-seq read counts
exdata_muscadet <- computeLogRatio(
    x = exdata_muscadet,
    reference = exdata_muscadet_ref,
    omic = "RNA",
    method = "RNA",
    refReads = 2, # low value for small example dataset
    refMeanReads = 0.01) 
```

To customize or refine the feature filtering applied by `computeLogRatio()`, users can inspect the data distributions and review the filter status of individual features before proceeding with downstream analyses.

```{r}
#| label: check features filters

library(ggplot2)

ATAC_features <- coordFeatures(exdata_muscadet)$ATAC

ggplot(ATAC_features, aes(x = nPeaks, y = meanReads.ref, color = keep)) +
    geom_point() +
    geom_vline(xintercept = 1 , linetype = "dashed", color = "red") + # minPeaks threshold
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "red") + # minReads threshold
    scale_y_log10() +
    labs(x = "Number of peaks (minPeaks)", y = "Mean of reads in reference cells (minReads)",
         title = "ATAC features (windows of peaks) filtered by thresholds") +
    theme_minimal()

RNA_features <- coordFeatures(exdata_muscadet)$RNA

ggplot(RNA_features, aes(x = sumReads.ref, y = meanReads.ref, color = keep)) +
    geom_point() +
    geom_vline(xintercept = 2, linetype = "dashed", color = "red") + # refReads threshold
    geom_hline(yintercept = 0.01, linetype = "dashed", color = "red") + # refMeanReads threshold
    scale_x_log10() + scale_y_log10() +
    labs(x = "Sum of reads in reference cells (refReads)", y = "Mean of reads in reference cells (refMeanReads)",
         title = "RNA features (genes) filtered by thresholds") +
    theme_minimal()

```


# Multimodal integrated clustering

Cells are clustered based on their log ratio profiles using the `clusterMuscadet()` function. Two clustering strategies are currently available:

* **`method = "seurat"`**: Graph-based clustering using the [`Seurat`](https://satijalab.org/seurat/) package. This approach constructs a nearest-neighbor graph from a weighted combination of multiple modalities, using selected principal components from each modality, followed by community detection to identify clusters (see `cluster_seurat()`).

* **`method = "hclust"`**: Multi-omic integration via Similarity Network Fusion (SNF), followed by hierarchical clustering of the fused similarity matrix to identify cell clusters (see `cluster_hclust()`).


```{r}
#| label: clustering 1
#| eval: true

# Set seed for clustering reproducibility
set.seed(123) 

# Perform clustering with "seurat" method
exdata_muscadet <- clusterMuscadet(
    x = exdata_muscadet,
    method = "seurat",
    res_range = c(0.1, 0.3, 0.5),
    dims_list = list(1:10, 1:10),
    knn_seurat = 10, # adapted to low number of cells in example data
    knn_range_seurat = 30 # adapted to low number of cells in example data
)
```

```{r}
#| label: clustering 2
#| eval: false

# Set seed for clustering reproducibility
set.seed(123)

# Perform clustering with "hclust" method
exdata_muscadet2 <- clusterMuscadet(
  x = exdata_muscadet,
  k_range = 2:4,
  method = "hclust",
  dist_method = "euclidean",
  hclust_method = "ward.D",
  weights = c(1, 1),
  quiet = TRUE
)
```

```{r}
#| label: clustering 3
# Number of cells per cluster per partition
lapply(exdata_muscadet$clustering$clusters, table)
```

# Clustering visualization

The distribution of cells across clustering partitions at different resolutions can be explored using `clustree()` from the [`clustree`](https://lazappi.github.io/clustree/index.html) package. 

```{r}
#| label: clustree
#| eval: !expr has_clustree

library(clustree)
# Build clustree
partitions <- lapply(exdata_muscadet$clustering$clusters, as.data.frame)
partitions <- do.call(cbind, partitions)
colnames(partitions) <- paste0("res_", names(exdata_muscadet$clustering$clusters))
clustree(partitions, prefix = "res_")
```

Genome-wide coverage profiles, along with the identified clusters, can be visualized as a heatmap with `heatmapMuscadet()`, on a selected clustering partition stored in the `muscadet` object. 


```{r}
#| label: heatmap 1
#| output: false
# Plot heatmap 
heatmapMuscadet(
    exdata_muscadet,
    filename = file.path("figures", "heatmap_res0.3.png"),
    partition = 0.3,
    title = "Example | res=0.3"
)
```

![Heatmap of log ratios](figures/heatmap_res0.3.png){#fig-ht width=100% fig-align="center"}
Additionally, an aggregated heatmap showing the average log ratio values per cluster can be plotted to summarize copy-number patterns across subclonal populations.

```{r}
#| label: heatmap 2
#| output: false
# Plot heatmap of log ratio averages per cluster
heatmapMuscadet(
    exdata_muscadet,
    filename = file.path("figures", "heatmap_res0.3_averages.png"),
    partition = 0.3,
    averages = TRUE,
    title = "Example | res=0.3 | Averages per cluster"
)
```

![Heatmap of log ratios averages per cluster](figures/heatmap_res0.3_averages.png){#fig-htavg width=100% fig-align="center"}

To visualize the integrated genome-wide coverage profiles, the data can be projected into a low-dimensional space using Uniform Manifold Approximation and Projection (UMAP). This projection provides an intuitive view of cell relationships, allowing users to explore subclonal structure and similarity between cells based on their multi-omic copy-number profiles.

```{r}
#| label: umap

plotUMAP(exdata_muscadet, partition = 0.3)
```


# Clustering validation

To assess the quality of the clustering partitions, Silhouette scores are computed and stored in the `muscadet` object. These scores can be visualized using `plotSil()`. 
Additional clustering validation metrics are also available and can be explored with `plotIndexes()`. Together, these tools help guide the selection of the most appropriate clustering partition for downstream analyses.


```{r}
#| label: silhouette
# View stored silhouette average widths per partition
exdata_muscadet$clustering$silhouette$sil.w.avg
```


```{r}
#| label: fig-sil
#| fig-cap: "Silhouette plot for a clustering partition"
# Silhouette plot for individual clustering partition
plotSil(exdata_muscadet, partition = 0.3)
```


```{r}
#| label: fig-sil2
#| fig-cap: "Plot of Silhouette scores across partitions"
# Plot clustering indexes for every stored partitions

plotIndexes(exdata_muscadet)
```


# CNA calling

Before calling CNAs, a clustering partition must be selected using `assignClusters()`.  

```{r}
#| label: assign clusters
#| eval: true
exdata_muscadet <- assignClusters(exdata_muscadet, partition = 0.3)
```

```{r}
#| label: show table clusters
table(exdata_muscadet$cnacalling$clusters)
```

Next, use `aggregateCounts()` with both the sample (tumor cells) and reference (normal cells) `muscadet` objects to combine counts per cluster across all omics. 

```{r}
#| label: aggregate counts
#| eval: true
# Aggregate counts per cluster from all omics from both sample and reference
exdata_muscadet <- aggregateCounts(exdata_muscadet, exdata_muscadet_ref)
```

Finally, run `cnaCalling()` to infer CNA segments for each cluster.
```{r}
#| label: CNA-calling
#| eval: true
exdata_muscadet <- cnaCalling(
    exdata_muscadet,
    depthmin.a.clusters = 3, # set low thresholds for example data
    depthmin.c.clusters = 5,
    depthmin.a.allcells = 3,
    depthmin.c.allcells = 5,
    depthmin.c.nor = 1
)
```

::: {.callout-note}
The default minimum depth (`depthmin.[...]`) filters may not be suitable for all datasets. It is recommended to inspect your data and adjust these parameters accordingly.
:::

::: {.callout-note}
The `omics.coverage` parameter can be set to one or more specific omics types (e.g., `"ATAC"` or `"RNA"`). This allows the CNA calling procedure to prioritize coverage from the selected omics, which can be useful when the signal from other modalities is noisy or less reliable.
:::


# CNA profiles

The resulting CNA calls can be visualized using `plotProfile()`, which generates a multi-panel profile per cluster summarizing:

* Coverage per feature: log ratios values of genes/peaks, segment medians and diploid log ratio (purple line). Deviations from 0 indicate gains (positive) or losses (negative) in coverage.
* Allele data: log odds ratio values (log-odds of reference vs alternative allele counts) at variant position and segment medians. Deviation from 0 suggests allelic imbalance, used to distinguish LOH, copy-neutral LOH, or allele-specific CNAs.
* Copy number calls: total and minor copy numbers per segment.
* CNA status classification: gain, loss or copy-neutral LOH statuses per segment.
* Cellular fraction: proportion of cells estimated to harbor the CNA at each segment.


```{r}
#| label: plot profile 1
plotProfile(exdata_muscadet, data = "1", title = "Cluster 1 profile", point.cex = 0.8)
```

```{r}
#| label: plot profile allcells
plotProfile(exdata_muscadet, data = "allcells", title = "Profile for all cells", point.cex = 0.8)
```

To view the complete CNA profile of the sample across clusters, use `plotCNA()`.

```{r}
#| label: plot CNA
#| warning: false
plotCNA(exdata_muscadet, cf.gradient = FALSE)
```





